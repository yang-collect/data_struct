# 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，
# 它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。
# 例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

class Solution:
    def movingCount(self, m: int, n: int, k: int) -> int:
        '''
        当前解法为bfs，即广度优先搜索，用一个列表来维护一个当前访问点的路径搜索表，
        bfs属于平推式搜索，并不会直接按一个方向搜索后再回退
        bfs：从图中一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。
        '''

        def sums(x):
            '''
            将坐标点的数字转换为各个位数的数字之和
            '''
            s=0
            while x!=0:
                s+=x%10
                x//=10
            return s
        # 用一个hash 表来保存可访问点
        vist=set()
        # 用一个列表来保存当前访问点
        search=[(0,0)]

        # 当前访问点为空时，即不存在可访问点，跳出循环
        while search:
            # 弹出当前的访问点
            x,y=search.pop()
            # 当当前访问点满足边界条件、在可访问点hash表中不存在且行列坐标数位之和不大于目标值时，
            # 将当前点坐标放入可访问点组成的hash表中
            if (x,y) not in vist and 0<=x<m and 0<=y<n and sums(x)+sums(y)<=k:
                vist.add((x,y))
                # 将当前可访问点的下方和右边的点放入访问点列表中
                search.append((x+1,y))
                search.append((x,y+1))
        
        return len(vist)
